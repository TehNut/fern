<script lang="ts">
	import { XMLBuilder } from "fast-xml-parser";
	import ChevronsUpDown from "lucide-svelte/icons/chevrons-up-down";
	import Download from "lucide-svelte/icons/download";
	import { fork } from "radash";
	import { onMount } from "svelte";
	import { MediaListStatus, MediaType, type FuzzyDate } from "$lib/anilist";
	import UserHeader from "$lib/components/UserHeader.svelte";
	import { Button } from "$lib/components/ui/button";
	import * as Collapsible from "$lib/components/ui/collapsible";
	import type { ExportEntry, ExportUser } from "../+page.svelte";
	import SkippedView from "./SkippedView.svelte";

	export let entries: ExportEntry[];
	export let user: ExportUser;
	export let mediaType: MediaType;
	export let updateOnImport: boolean;

	let skippedEntries: ExportEntry[] = [];
	let exportedData: string = "";

	function createExport() {
		const [exportable, skip] = fork(entries, (e) => e.media.idMal > 0);

		const exportData = {
			myanimelist: {
				myinfo: {
					user_id: "",
					user_name: user.name,
					user_export_type: mediaType === MediaType.ANIME ? 1 : 2,
					[`user_total_${mediaType.toLowerCase()}`]: exportable.length,
					[`user_total_${mediaType === MediaType.ANIME ? "watching" : "reading"}`]:
						exportable.filter((e) => e.status === "CURRENT").length,
					user_total_completed: exportable.filter((e) => e.status === "COMPLETED").length,
					user_total_on_hold: exportable.filter((e) => e.status === "PAUSED").length,
					user_total_dropped: exportable.filter((e) => e.status === "DROPPED").length,
					[`user_total_planto${mediaType === MediaType.ANIME ? "watch" : "read"}`]:
						exportable.filter((e) => e.status === "PLANNING").length
				},
				[`${mediaType.toLowerCase()}`]: exportable.map((e) => {
					return {
						// Media data
						...(mediaType === MediaType.ANIME
							? {
									series_animedb_id: e.media.idMal,
									series_title: { text: e.media.title.romaji },
									series_episodes: e.media.episodes,
									// Unused
									series_type: ""
								}
							: {
									manga_mangadb_id: e.media.idMal,
									manga_title: { text: e.media.title.romaji },
									manga_chapters: e.media.episodes || 0,
									manga_volumes: e.media.volumes || 0
									// Unused
								}),
						// List data
						...(mediaType === MediaType.ANIME
							? {
									my_watched_episodes: e.progress,
									my_times_watched: (function () {
										switch (e.status) {
											case MediaListStatus.COMPLETED:
											case MediaListStatus.REPEATING:
												return 1 + e.repeat;
											default:
												return 0;
										}
									})(),
									my_rewatching: e.status === MediaListStatus.REPEATING ? 1 : 0,
									my_rewatching_ep: e.status === MediaListStatus.REPEATING ? e.progress : 0,
									// Unused
									my_rewatch_value: "",
									my_rated: "",
									my_dvd: ""
								}
							: {
									my_read_volumes: e.progressVolumes,
									my_read_chapters: e.progress,
									my_times_read: (function () {
										switch (e.status) {
											case MediaListStatus.COMPLETED:
											case MediaListStatus.REPEATING:
												return 1 + e.repeat;
											default:
												return 0;
										}
									})(),
									// Unused
									my_scanlation_group: { text: "" },
									my_reread_value: ""
								}),
						my_start_date: `${formatDate(e.startedAt)}`,
						my_finish_date: `${formatDate(e.completedAt)}`,
						my_score: e.score,
						my_status: toMalStatus(e.status),
						my_comments: { text: e.notes || "" },
						update_on_import: updateOnImport ? 1 : 0,
						// Unused
						my_id: 0,
						my_storage: "",
						my_tags: { text: "" }
					};
				})
			}
		};

		const xml = new XMLBuilder({
			format: true,
			cdataPropName: "text"
		});

		exportedData = "<!--\n  Generated by Fern (https://fern.ignoffo.dev)\n\n";
		if (skip.length) {
			const skippedText = skip.map(
				(e) =>
					`https://anilist.co/${mediaType.toLowerCase()}/${e.media.id}: ${e.media.title.romaji}`
			);
			exportedData += `  Missing MAL mappings:\n\n  - ${skippedText.join("\n  - ")}\n-->\n\n`;
		}
		exportedData += xml.build(exportData);
		skippedEntries = skip;
	}

	function saveExport() {
		const blob = new Blob([exportedData], {
			type: "text/xml"
		});
		const url = URL.createObjectURL(blob);

		const a = document.createElement("a");
		a.href = url;
		a.download = `${user.name}_${mediaType.toLowerCase()}_export_${new Date().getTime()}.xml`;
		a.click();
	}

	function formatDate(date?: FuzzyDate): string {
		return `${date?.year || "0000"}-${date?.month || "00"}-${date?.day || "00"}`;
	}

	function toMalStatus(status: MediaListStatus): string {
		switch (status) {
			case MediaListStatus.CURRENT:
				return mediaType === MediaType.ANIME ? "Watching" : "Reading";
			case MediaListStatus.COMPLETED:
				return "Completed";
			case MediaListStatus.PAUSED:
				return "On-Hold";
			case MediaListStatus.DROPPED:
				return "Dropped";
			case MediaListStatus.PLANNING:
				return "Plan to Watch";
			default:
				return "";
		}
	}

	onMount(() => {
		createExport();
	});
</script>

<Collapsible.Root class="grid gap-4">
	<UserHeader name={user.name} avatar={user.avatar.large}>
		<div class="flex gap-2" slot="below-name">
			<p class="text-sm">
				{skippedEntries.length} entries were skipped due to missing MAL mapping. Expand to view.
			</p>
		</div>
		<div class="flex gap-2" slot="actions">
			<Button variant="ghost" size="icon" class="h-8 w-8" on:click={() => saveExport()}>
				<Download />
				<span class="sr-only">Download</span>
			</Button>
			<Collapsible.Trigger asChild let:builder>
				<Button builders={[builder]} variant="ghost" size="icon" class="h-8 w-8">
					<ChevronsUpDown />
					<span class="sr-only">Toggle</span>
				</Button>
			</Collapsible.Trigger>
		</div>
	</UserHeader>
	<Collapsible.Content>
		<SkippedView skipped={skippedEntries} />
	</Collapsible.Content>
</Collapsible.Root>
