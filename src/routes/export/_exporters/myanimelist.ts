import { XMLBuilder } from "fast-xml-parser";
import { fork } from "radash";
import { MediaListStatus, MediaType } from "$lib/anilist";
import type { ExportEntry, ExportUser } from "../+page.svelte";
import { formatDate } from ".";

export function createMyAnimeListExport(entries: ExportEntry[], user: ExportUser, mediaType: MediaType, updateOnImport: boolean): [string, ExportEntry[]] {
	const [exportable, skipped] = fork(entries, (e) => e.media.idMal > 0);
	let exportedData = "";

	const exportData = {
		myanimelist: {
			myinfo: {
				user_id: "",
				user_name: user.name,
				user_export_type: mediaType === MediaType.ANIME ? 1 : 2,
				[`user_total_${mediaType.toLowerCase()}`]: exportable.length,
				[`user_total_${mediaType === MediaType.ANIME ? "watching" : "reading"}`]:
					exportable.filter((e) => e.status === "CURRENT").length,
				user_total_completed: exportable.filter((e) => e.status === "COMPLETED").length,
				user_total_on_hold: exportable.filter((e) => e.status === "PAUSED").length,
				user_total_dropped: exportable.filter((e) => e.status === "DROPPED").length,
				[`user_total_planto${mediaType === MediaType.ANIME ? "watch" : "read"}`]:
					exportable.filter((e) => e.status === "PLANNING").length
			},
			[`${mediaType.toLowerCase()}`]: exportable.map((e) => {
				return {
					// Media data
					...(mediaType === MediaType.ANIME
						? {
							series_animedb_id: e.media.idMal,
							series_title: { text: e.media.title.romaji },
							series_episodes: e.media.episodes,
							// Unused
							series_type: ""
						}
						: {
							manga_mangadb_id: e.media.idMal,
							manga_title: { text: e.media.title.romaji },
							manga_chapters: e.media.episodes || 0,
							manga_volumes: e.media.volumes || 0
							// Unused
						}),
					// List data
					...(mediaType === MediaType.ANIME
						? {
							my_watched_episodes: e.progress,
							my_times_watched: (function () {
								switch (e.status) {
									case MediaListStatus.COMPLETED:
									case MediaListStatus.REPEATING:
										return 1 + e.repeat;
									default:
										return 0;
								}
							})(),
							my_rewatching: e.status === MediaListStatus.REPEATING ? 1 : 0,
							my_rewatching_ep: e.status === MediaListStatus.REPEATING ? e.progress : 0,
							// Unused
							my_rewatch_value: "",
							my_rated: "",
							my_dvd: ""
						}
						: {
							my_read_volumes: e.progressVolumes,
							my_read_chapters: e.progress,
							my_times_read: (function () {
								switch (e.status) {
									case MediaListStatus.COMPLETED:
									case MediaListStatus.REPEATING:
										return 1 + e.repeat;
									default:
										return 0;
								}
							})(),
							// Unused
							my_scanlation_group: { text: "" },
							my_reread_value: ""
						}),
					my_start_date: `${formatDate(e.startedAt)}`,
					my_finish_date: `${formatDate(e.completedAt)}`,
					my_score: e.score,
					my_status: toMalStatus(e.status, mediaType),
					my_comments: { text: e.notes || "" },
					update_on_import: updateOnImport ? 1 : 0,
					// Unused
					my_id: 0,
					my_storage: "",
					my_tags: { text: "" }
				};
			})
		}
	};

	const xml = new XMLBuilder({
		format: true,
		cdataPropName: "text"
	});

	exportedData = "<!--\n  Generated by Fern (https://fern.ignoffo.dev)\n\n";
	if (skipped.length) {
		const skippedText = skipped.map(
			(e) =>
				`https://anilist.co/${mediaType.toLowerCase()}/${e.media.id}: ${e.media.title.romaji}`
		);
		exportedData += `  Missing MAL mappings:\n\n  - ${skippedText.join("\n  - ")}\n-->\n\n`;
	}
	exportedData += xml.build(exportData);

	return [exportedData, skipped];
}

function toMalStatus(status: MediaListStatus, mediaType: MediaType): string {
	switch (status) {
		case MediaListStatus.CURRENT:
			return mediaType === MediaType.ANIME ? "Watching" : "Reading";
		case MediaListStatus.COMPLETED:
			return "Completed";
		case MediaListStatus.PAUSED:
			return "On-Hold";
		case MediaListStatus.DROPPED:
			return "Dropped";
		case MediaListStatus.PLANNING:
			return mediaType === MediaType.ANIME ? "Plan to Watch" : "Plan to Read";
		default:
			return "";
	}
}